## 四、程序实现和实验测试过程

### 1 验证算法的正确性

我们搜集了用python语言解决该题并通过洛谷对应测试的四种实现，分别封装成提供数据规模`n:int`和距离表`time_map:list[list[int]]`，返回最短路程长度的函数：

```python
def solve(n:int, time_map:list[list[int]]) -> int:
    ...
```

我们实现了一个`testcase`生成器，用于产生不同数据规模`n`、不同连通率`ratio`的邻接矩阵：

```python
from random import randrange

def generate_testcase(n, ratio=1) -> list[list[int]]:
    MAX = _MAX // n
    time_map = [[-1] * n for _ in range(n)]

    while True:
        for i in range(n):
            time_map[i][i] = 0

        for i, j in combinations(range(n), 2):
            time_map[i][j] = time_map[j][i] = randrange(MAX)

        for _ in range(int(n * n * (1 - ratio))):
            while True:
                i, j = randrange(n), randrange(n)
                if i != j and time_map[i][j] != -1:
                    time_map[i][j] = -1
                    break
        
        if check_connect(time_map):
            return time_map
```

其中`check_connect`是检测图是否连通的函数，它确保`generate_testcase`生成的测试点数据是合理的。

我们在各种大小的地图中，始终确保四个算法的返回值相同。

```python
from solutions.wyh_solution import solve as solve_0
from solutions.lx_solution import solve as solve_1
from solutions.BF_solution import solve as solve_2
from solutions.DP_solution import solve as solve_3

args = n, time_map = ...
assert solve_0(*args) == solve_1(*args) == solve_2(*args) == solve_3(*args)
```

在运行了数十亿次不同的`testcase`中，该断言从未报错，证明四个算法的结果一致，算法正确性得证。

### 2 对于给定的输入，比较同类算法的性能

我们主要关注时间复杂度与数据规模`n`的关系。令`ratio=0.9`，让`n`遍历3到15，比较四种算法耗费的时间。

```python
def run(func, *args, n=10_000) -> float:
    t = time()
    for _ in range(n):
        func(*args)
    return time() - t
```

`run`函数能统计`func`运行`n`次的耗时

### 3 数据分析

#### 3.1 比率测试

#### 3.2 幂测试
